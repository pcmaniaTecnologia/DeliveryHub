
/**
 * Core Philosophy: This ruleset enforces a multi-tenant security model for a SaaS delivery platform.
 * Access is primarily governed by a user's membership within a specific company. A global "super admin"
 * role exists for system-wide management, capable of overriding tenant-specific permissions. Data is
 * strictly segregated by company to prevent cross-tenant data leakage.
 *
 * Data Structure: The majority of application data (users, products, orders, etc.) is nested
 * under the /companies/{companyId} collection. This hierarchical structure provides a strong security
 * boundary for each tenant. Top-level collections are used for globally shared or independent data,
 * such as /customers, /plans, and /roles_admin for the super admin lookup.
 *
 * Key Security Decisions:
 * - Company Segregation: A user associated with one company cannot read or write data belonging to another.
 * - Global Admins: A lookup collection /roles_admin/{userId} grants super admin privileges, providing
 *   a centralized and auditable way to manage top-level permissions.
 * - Customer Privacy: Customers can only access their own profile in /customers/{customerId}. Listing
 *   of all customers is explicitly forbidden to protect user privacy.
 * - Public vs. Private Data: Company product catalogs and general info are public-readable to allow for
 *   unauthenticated browsing. Sensitive data like orders and company member lists are restricted.
 *
 * Denormalization for Authorization: To ensure fast and simple authorization checks, this ruleset
 * relies on denormalized data. Most documents within a company's data tree contain a `companyId` field.
 * This avoids costly and slow `get()` calls to parent documents for permission checks. Similarly, company
 * user roles are stored directly on the user document in `/companies/{companyId}/users/{userId}`, allowing
 * for direct role verification.
 *
 * Structural Segregation: The data model naturally separates tenant data using distinct paths
 * (e.g., /companies/{companyId}/...). This is the most secure and performant way to handle multi-tenancy,
 * especially for list operations, as security rules can rely on the path itself to scope queries.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ------------------------------------------------------------------------
    // Helper Functions
    // ------------------------------------------------------------------------

    /**
     * Returns true if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Returns true if the requesting user has a document in the /roles_admin collection,
     * granting them global administrator privileges.
     */
    function isSuperAdmin() {
      return exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    /**
     * Returns true if the user's UID matches the provided userId.
     * This is the primary function for checking document ownership.
     */
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    /**
     * Returns true if a user is a member of a specific company.
     * This check is performant as it only verifies document existence.
     */
    function isCompanyMember(companyId) {
      return exists(/databases/$(database)/documents/companies/$(companyId)/users/$(request.auth.uid));
    }

    /**
     * Returns true if a user is an 'admin' of a specific company.
     * This requires a document read and should be used for role-specific permissions.
     */
    function isCompanyAdmin(companyId) {
      return get(/databases/$(database)/documents/companies/$(companyId)/users/$(request.auth.uid)).data.role == 'admin';
    }

    /**
     * Ensures an incoming document on creation has an ownership field that
     * matches the authenticated user's ID.
     */
    function isCreatingOwnDoc(userId) {
      return isOwner(userId) && request.resource.data.id == userId;
    }
    
    /**
     * Ensures the incoming document on company creation has an ownerId and id matching the user's UID.
     */
    function isCreatingOwnCompany(companyId) {
      return isOwner(companyId) && request.resource.data.ownerId == request.auth.uid;
    }

    /**
     * Ensures the `ownerId` of an existing document matches the user.
     */
    function isCompanyOwner(companyId) {
        return request.auth.uid == get(/databases/$(database)/documents/companies/$(companyId)).data.ownerId;
    }

    /**
     * Ensures an ownership field is not changed during an update.
     * This allows partial updates while maintaining ownership integrity.
     */
    function isMaintainingOwnDoc() {
      return request.resource.data.id == resource.data.id;
    }

    // ------------------------------------------------------------------------
    // Collection Group Rules
    // ------------------------------------------------------------------------

    /**
     * @description Collection group rule for orders. Allows super admins to list all orders across all companies.
     * @path /companies/{companyId}/orders/{orderId}
     * @allow (list) A super admin lists all orders for the dashboard analytics.
     * @principle Grants wide-ranging read access on a specific collection group only to the highest privilege level.
     */
    match /{path=**}/orders/{orderId} {
      // Allow super admins to list all orders across all companies for the admin dashboard.
      allow list: if isSuperAdmin();
    }

    // ------------------------------------------------------------------------
    // Collection Rules
    // ------------------------------------------------------------------------

    /**
     * @description Manages company profiles. Publicly readable, but only writable by company admins or super admins.
     * @path /companies/{companyId}
     * @allow (get) Any user, authenticated or not, can read a company's profile.
     * @deny (update) A regular member of the company tries to update the company profile.
     * @principle Enforces role-based access for company management while allowing public read access for storefronts.
     */
    match /companies/{companyId} {
      allow get: if true;
      allow list: if isSuperAdmin();
      allow create: if isCreatingOwnCompany(companyId);
      allow update: if isCompanyOwner(companyId) || isSuperAdmin();
      allow delete: if isSuperAdmin() && resource != null;
    }

    /**
     * @description Manages user accounts within a company. Users can read their own profile. Company admins can manage all users in their company.
     * @path /companies/{companyId}/users/{userId}
     * @allow (get) An authenticated user reads their own user document.
     * @deny (list) A regular company member tries to list all other users in the company.
     * @deny (update) A user tries to change their own role from 'attendant' to 'admin'.
     * @principle Restricts access to a user's own data and grants broader permissions to company administrators. Prevents privilege escalation.
     */
    match /companies/{companyId}/users/{userId} {
      allow get: if isOwner(userId) || isCompanyAdmin(companyId) || isSuperAdmin();
      allow list: if isCompanyAdmin(companyId) || isSuperAdmin();
      // Allow user to create their own doc if they are the owner and companyId matches their UID (initial signup)
      // OR allow a company admin/super admin to create users.
      allow create: if (isOwner(userId) && companyId == request.auth.uid) || isCompanyAdmin(companyId) || isSuperAdmin();
      allow update: if resource != null && (isCompanyAdmin(companyId) || isSuperAdmin() || (isOwner(userId) && request.resource.data.role == resource.data.role));
      allow delete: if (isCompanyAdmin(companyId) || isSuperAdmin()) && resource != null;
    }

    /**
     * @description Manages the product catalog for a company. Products are public to view, but only company members can manage them.
     * @path /companies/{companyId}/products/{productId}
     * @allow (list) Any user, including unauthenticated ones, can list the products for a company.
     * @deny (create) A user who is not a member of the company tries to add a new product.
     * @principle Implements a "Public Read, Owner-Only Write" pattern, where "owner" refers to any member of the parent company.
     */
    match /companies/{companyId}/products/{productId} {
      allow get, list: if true;
      allow create: if (isCompanyMember(companyId) || isSuperAdmin()) && request.resource.data.companyId == companyId;
      allow update: if (isCompanyMember(companyId) || isSuperAdmin()) && resource != null && request.resource.data.companyId == resource.data.companyId;
      allow delete: if (isCompanyMember(companyId) || isSuperAdmin()) && resource != null;
    }

    /**
     * @description Manages product categories. Public to view, writable by company members.
     * @path /companies/{companyId}/categories/{categoryId}
     * @allow (get) Any user can view product categories.
     * @deny (update) An anonymous user tries to change a category name.
     * @principle Implements a "Public Read, Owner-Only Write" pattern for catalog organization.
     */
    match /companies/{companyId}/categories/{categoryId} {
      allow get, list: if true;
      allow create: if (isCompanyMember(companyId) || isSuperAdmin()) && request.resource.data.companyId == companyId;
      allow update: if (isCompanyMember(companyId) || isSuperAdmin()) && resource != null;
      allow delete: if (isCompanyMember(companyId) || isSuperAdmin()) && resource != null;
    }

    /**
     * @description Manages product subcategories. Public to view, writable by company members.
     * @path /companies/{companyId}/subcategories/{subcategoryId}
     * @allow (get) Any user can view product subcategories.
     * @deny (create) A user from a different company tries to add a subcategory.
     * @principle Implements a "Public Read, Owner-Only Write" pattern for catalog organization.
     */
    match /companies/{companyId}/subcategories/{subcategoryId} {
      allow get, list: if true;
      allow create: if isCompanyMember(companyId) || isSuperAdmin();
      allow update: if (isCompanyMember(companyId) || isSuperAdmin()) && resource != null;
      allow delete: if (isCompanyMember(companyId) || isSuperAdmin()) && resource != null;
    }

    /**
     * @description Manages discount coupons for a company. Readable and writable only by company members to prevent abuse.
     * @path /companies/{companyId}/coupons/{couponId}
     * @allow (get) A company member reads a coupon's details.
     * @deny (list) An end customer tries to list all available coupons for a company.
     * @principle Secures sensitive business information (discount codes) by restricting all access to authorized company personnel.
     */
    match /companies/{companyId}/coupons/{couponId} {
      allow get, list: if isCompanyMember(companyId) || isSuperAdmin();
      allow create: if (isCompanyMember(companyId) || isSuperAdmin()) && request.resource.data.companyId == companyId;
      allow update: if (isCompanyMember(companyId) || isSuperAdmin()) && resource != null;
      allow delete: if (isCompanyMember(companyId) || isSuperAdmin()) && resource != null;
    }

    /**
     * @description Manages customer orders. Writable by any user, readable/updatable by company members or the customer who owns it.
     * @path /companies/{companyId}/orders/{orderId}
     * @allow (create) Any user (authenticated or not) creates a new order.
     * @allow (get) The customer who placed the order retrieves its status.
     * @deny (list) A customer tries to list all orders for the company without filtering.
     * @principle Enforces shared access between the document owner (customer) and business operators (company members).
     */
    match /companies/{companyId}/orders/{orderId} {
      allow get: if isCompanyMember(companyId) || isSuperAdmin() || (isSignedIn() && resource.data.customerId == request.auth.uid);
      allow list: if isCompanyMember(companyId) || isSuperAdmin(); // Restricting list to members/admins for security.
      allow create: if request.resource.data.companyId == companyId;
      allow update: if (isCompanyMember(companyId) || isSuperAdmin()) && resource != null;
      allow delete: if false;
    }

    /**
     * @description Manages items within an order. Access is inherited from the parent order document.
     * @path /companies/{companyId}/orders/{orderId}/orderItems/{orderItemId}
     * @allow (get) A customer reads the items list for an order they placed.
     * @deny (create) A user tries to add an item to an order that is not theirs.
     * @principle Secures subcollection data by checking permissions on the parent document using a `get()` call.
     */
    match /companies/{companyId}/orders/{orderId}/orderItems/{orderItemId} {
      allow get, list: if isCompanyMember(companyId) || isSuperAdmin() || (isSignedIn() && get(/databases/$(database)/documents/companies/$(companyId)/orders/$(orderId)).data.customerId == request.auth.uid);
      allow create: if true; // The check is done on the parent order
      allow update: if false;
      allow delete: if false;
    }
    
    /**
     * @description Manages delivery zones for a company. Public to read, writable by company members.
     * @path /companies/{companyId}/deliveryZones/{deliveryZoneId}
     * @allow (list) An end customer lists delivery zones to see if their area is covered.
     * @deny (update) An anonymous user tries to change a delivery fee.
     * @principle Implements a "Public Read, Owner-Only Write" pattern for logistical data.
     */
    match /companies/{companyId}/deliveryZones/{deliveryZoneId} {
      allow get, list: if true;
      allow create: if (isCompanyMember(companyId) || isSuperAdmin()) && request.resource.data.companyId == companyId;
      allow update: if (isCompanyMember(companyId) || isSuperAdmin()) && resource != null;
      allow delete: if (isCompanyMember(companyId) || isSuperAdmin()) && resource != null;
    }

    /**
     * @description Manages customer profiles. A user can only access and manage their own profile. Super admins can also read.
     * @path /customers/{customerId}
     * @allow (create) A new user signs up and creates their own customer profile document.
     * @deny (get) A user tries to read the profile data of another user (unless they are a super admin).
     * @deny (list) Any user tries to list all customers in the database.
     * @principle Enforces a strict data ownership model and prevents user enumeration, while allowing admin oversight.
     */
    match /customers/{customerId} {
      allow get: if isOwner(customerId) || isSuperAdmin();
      allow list: if false;
      allow create: if isCreatingOwnDoc(customerId);
      allow update: if isOwner(customerId) && resource != null && isMaintainingOwnDoc();
      allow delete: if isOwner(customerId) && resource != null;
    }

    /**
     * @description Defines subscription plans. Publicly readable, but only super admins can create or modify them.
     * @path /plans/{planId}
     * @allow (list) Any user, including unauthenticated ones, can list the available subscription plans.
     * @deny (create) A regular authenticated user tries to create a new plan.
     * @principle Protects critical business model data (pricing) while making it publicly available for marketing.
     */
    match /plans/{planId} {
      allow get, list: if true;
      allow create: if isSuperAdmin();
      allow update: if isSuperAdmin() && resource != null;
      allow delete: if isSuperAdmin() && resource != null;
    }
    
    /**
     * @description Global platform settings. Readable by anyone (to get PIX key), writable only by super admins.
     * @path /platform_settings/{settingsId}
     * @allow (read) Any user can read the platform PIX key to pay for a subscription.
     * @deny (write) A non-admin user tries to change the platform's PIX key.
     * @principle Secures global configuration while exposing necessary public data for core business logic (payments).
     */
    match /platform_settings/{settingsId} {
      allow read: if true;
      allow create, update, delete: if isSuperAdmin();
    }

    /**
     * @description Manages global super admin roles. Only other super admins can view or modify this collection.
     * @path /roles_admin/{userId}
     * @allow (get, create, update, delete) A super admin manages the roles of another user.
     * @deny (get, create, update, delete) Any user who is not a super admin tries to access this collection.
     * @principle Secures the highest level of administrative access,
    ensuring only authorized personnel can manage roles.
     */
    match /roles_admin/{userId} {
      allow get: if isOwner(userId) || isSuperAdmin();
      allow list: if isSuperAdmin();
      allow create: if isOwner(userId) || isSuperAdmin();
      allow update: if isSuperAdmin() && resource != null;
      allow delete: if isSuperAdmin() && resource != null;
    }
  }
}
